t2 = stats::integrate(myfunc, lower=0, upper=pi, rel.tol=sqrt(.Machine$double.eps))$value
return(t1*t2)
}
C = sum(aux_dist_1toN(mymean, myx)^2)
D = ncol(myx)
n = nrow(myx)
vec.lambda = seq(from=0,to=20,length.out=200)
vec.cost   = rep(0,length(vec.lambda))
for (i in 1:length(vec.lambda)){
tl = vec.lambda[i]
term1 = -(tl/2)*C
term2 = -n*log(dspnorm.constant(tl,D))
vec.cost[i] = term1+term2
}
lopt = vec.lambda[which.max(vec.cost)]
hey = mle.spnorm(myx)
plot(vec.lambda, vec.cost, main="red-MLE, blue-TRUE")
abline(v=hey$method3, lwd=2, col="red")
abline(v=mylbd, lwd=2, col="blue")
myp   = 5
mylbd = stats::runif(1, min=0.0001, max=18)
myn   = 1000
aux_log <- function(mu, x){
theta = base::acos(sum(x*mu))
if (abs(theta)<sqrt(.Machine$double.eps)){
output = x-mu*(sum(x*mu))
} else {
output = (x-mu*(sum(x*mu)))*theta/sin(theta)
}
return(output)
}
check_single <- function(x){
return(sum(x^2))
}
aux_dist_1toN <- function(x, maty){
dist_one <- function(y){
logxy = aux_log(x, y)
return(sqrt(sum(logxy^2)))
}
return(apply(maty, 1, dist_one))
}
library(RiemBase)
mymu  = rnorm(myp)
mymu  = mymu/sqrt(sum(mymu^2))
myx   = RiemSphere::rspnorm(myn, mymu, lambda=mylbd)
mymean = as.vector(rbase.mean(riemfactory(t(myx), name="sphere"))$x)
dspnorm.constant <- function(lbd, D){ # lbd : lambda / D : dimension
myfunc <- function(r){
return(exp(-lbd*(r^2)/2)*((sin(r))^(D-2)))
}
t1 = 2*(pi^((D-1)/2))/gamma((D-1)/2) # one possible source of error
t2 = stats::integrate(myfunc, lower=0, upper=pi, rel.tol=sqrt(.Machine$double.eps))$value
return(t1*t2)
}
C = sum(aux_dist_1toN(mymean, myx)^2)
D = ncol(myx)
n = nrow(myx)
vec.lambda = seq(from=0,to=20,length.out=200)
vec.cost   = rep(0,length(vec.lambda))
for (i in 1:length(vec.lambda)){
tl = vec.lambda[i]
term1 = -(tl/2)*C
term2 = -n*log(dspnorm.constant(tl,D))
vec.cost[i] = term1+term2
}
lopt = vec.lambda[which.max(vec.cost)]
hey = mle.spnorm(myx)
plot(vec.lambda, vec.cost, main="red-MLE, blue-TRUE")
abline(v=hey$method3, lwd=2, col="red")
abline(v=mylbd, lwd=2, col="blue")
install.packages("microbenchmark")
library(microbenchmark)
help("microbenchmark")
help(swtich)
help("switch")
library(RiemSphere)
myp   = 5
mylbd = stats::runif(1, min=0.0001, max=18)
myn   = 1000
aux_log <- function(mu, x){
theta = base::acos(sum(x*mu))
if (abs(theta)<sqrt(.Machine$double.eps)){
output = x-mu*(sum(x*mu))
} else {
output = (x-mu*(sum(x*mu)))*theta/sin(theta)
}
return(output)
}
check_single <- function(x){
return(sum(x^2))
}
aux_dist_1toN <- function(x, maty){
dist_one <- function(y){
logxy = aux_log(x, y)
return(sqrt(sum(logxy^2)))
}
return(apply(maty, 1, dist_one))
}
library(RiemBase)
mymu  = rnorm(myp)
mymu  = mymu/sqrt(sum(mymu^2))
myx   = RiemSphere::rspnorm(myn, mymu, lambda=mylbd)
mymean = as.vector(rbase.mean(riemfactory(t(myx), name="sphere"))$x)
dspnorm.constant <- function(lbd, D){ # lbd : lambda / D : dimension
myfunc <- function(r){
return(exp(-lbd*(r^2)/2)*((sin(r))^(D-2)))
}
t1 = 2*(pi^((D-1)/2))/gamma((D-1)/2) # one possible source of error
t2 = stats::integrate(myfunc, lower=0, upper=pi, rel.tol=sqrt(.Machine$double.eps))$value
return(t1*t2)
}
C = sum(aux_dist_1toN(mymean, myx)^2)
D = ncol(myx)
n = nrow(myx)
vec.lambda = seq(from=0,to=20,length.out=200)
vec.cost   = rep(0,length(vec.lambda))
for (i in 1:length(vec.lambda)){
tl = vec.lambda[i]
term1 = -(tl/2)*C
term2 = -n*log(dspnorm.constant(tl,D))
vec.cost[i] = term1+term2
}
lopt = vec.lambda[which.max(vec.cost)]
hey = mle.spnorm(myx)
plot(vec.lambda, vec.cost, main="red-MLE, blue-TRUE")
abline(v=hey$method3, lwd=2, col="red")
abline(v=mylbd, lwd=2, col="blue")
library(microbenchmark)  # time comparison of multiple methods
lbdtime <- microbenchmark(
deoptim = mle.spnorm(myx, method=1),
statopt = mle.spnorm(myx, method=2),
newtons = mle.spnorm(myx, method=3)
)
library(ggplot2)
autoplot(lbdtime)
help("microbenchmark")
myp   = 5
mylbd = stats::runif(1, min=0.0001, max=18)
myn   = 500
aux_log <- function(mu, x){
theta = base::acos(sum(x*mu))
if (abs(theta)<sqrt(.Machine$double.eps)){
output = x-mu*(sum(x*mu))
} else {
output = (x-mu*(sum(x*mu)))*theta/sin(theta)
}
return(output)
}
check_single <- function(x){
return(sum(x^2))
}
aux_dist_1toN <- function(x, maty){
dist_one <- function(y){
logxy = aux_log(x, y)
return(sqrt(sum(logxy^2)))
}
return(apply(maty, 1, dist_one))
}
library(RiemBase)
mymu  = rnorm(myp)
mymu  = mymu/sqrt(sum(mymu^2))
myx   = RiemSphere::rspnorm(myn, mymu, lambda=mylbd)
mymean = as.vector(rbase.mean(riemfactory(t(myx), name="sphere"))$x)
dspnorm.constant <- function(lbd, D){ # lbd : lambda / D : dimension
myfunc <- function(r){
return(exp(-lbd*(r^2)/2)*((sin(r))^(D-2)))
}
t1 = 2*(pi^((D-1)/2))/gamma((D-1)/2) # one possible source of error
t2 = stats::integrate(myfunc, lower=0, upper=pi, rel.tol=sqrt(.Machine$double.eps))$value
return(t1*t2)
}
C = sum(aux_dist_1toN(mymean, myx)^2)
D = ncol(myx)
n = nrow(myx)
vec.lambda = seq(from=0,to=20,length.out=200)
vec.cost   = rep(0,length(vec.lambda))
for (i in 1:length(vec.lambda)){
tl = vec.lambda[i]
term1 = -(tl/2)*C
term2 = -n*log(dspnorm.constant(tl,D))
vec.cost[i] = term1+term2
}
lopt = vec.lambda[which.max(vec.cost)]
hey = mle.spnorm(myx)
plot(vec.lambda, vec.cost, main="red-MLE, blue-TRUE")
abline(v=hey$method3, lwd=2, col="red")
abline(v=mylbd, lwd=2, col="blue")
library(ggplot2)
library(microbenchmark)  # time comparison of multiple methods
lbdtime <- microbenchmark(
deoptim = mle.spnorm(myx, method=1),
statopt = mle.spnorm(myx, method=2),
newtons = mle.spnorm(myx, method=3), times=20L
)
autoplot(lbdtime)
help(mle)
library(Directional)
help(vmf)
x <- rvmf(100, m, 7)
x <- rvmf(myn, mymu, 7)
mle.spnorm(x)
library(RiemSphere)
mle.spnorm(x)
x <- rspnorm(myn, mymu, 7)
mle.spnorm(x)
mymu
myp   = 5
mylbd = stats::runif(1, min=0.0001, max=18)
myn   = 500
aux_log <- function(mu, x){
theta = base::acos(sum(x*mu))
if (abs(theta)<sqrt(.Machine$double.eps)){
output = x-mu*(sum(x*mu))
} else {
output = (x-mu*(sum(x*mu)))*theta/sin(theta)
}
return(output)
}
check_single <- function(x){
return(sum(x^2))
}
aux_dist_1toN <- function(x, maty){
dist_one <- function(y){
logxy = aux_log(x, y)
return(sqrt(sum(logxy^2)))
}
return(apply(maty, 1, dist_one))
}
library(RiemBase)
mymu  = rnorm(myp)
mymu  = mymu/sqrt(sum(mymu^2))
myx   = RiemSphere::rspnorm(myn, mymu, lambda=mylbd)
mymean = as.vector(rbase.mean(riemfactory(t(myx), name="sphere"))$x)
dspnorm.constant <- function(lbd, D){ # lbd : lambda / D : dimension
myfunc <- function(r){
return(exp(-lbd*(r^2)/2)*((sin(r))^(D-2)))
}
t1 = 2*(pi^((D-1)/2))/gamma((D-1)/2) # one possible source of error
t2 = stats::integrate(myfunc, lower=0, upper=pi, rel.tol=sqrt(.Machine$double.eps))$value
return(t1*t2)
}
C = sum(aux_dist_1toN(mymean, myx)^2)
D = ncol(myx)
n = nrow(myx)
# test 1. shape of log-likelihood function --------------------------------
vec.lambda = seq(from=0,to=20,length.out=200)
vec.cost   = rep(0,length(vec.lambda))
for (i in 1:length(vec.lambda)){
tl = vec.lambda[i]
term1 = -(tl/2)*C
term2 = -n*log(dspnorm.constant(tl,D))
vec.cost[i] = term1+term2
}
lopt = vec.lambda[which.max(vec.cost)]
hey = mle.spnorm(myx)
plot(vec.lambda, vec.cost, main="red-MLE, blue-TRUE")
abline(v=hey$method3, lwd=2, col="red")
abline(v=mylbd, lwd=2, col="blue")
myp   = 5
mylbd = stats::runif(1, min=0.0001, max=18)
myn   = 500
aux_log <- function(mu, x){
theta = base::acos(sum(x*mu))
if (abs(theta)<sqrt(.Machine$double.eps)){
output = x-mu*(sum(x*mu))
} else {
output = (x-mu*(sum(x*mu)))*theta/sin(theta)
}
return(output)
}
check_single <- function(x){
return(sum(x^2))
}
aux_dist_1toN <- function(x, maty){
dist_one <- function(y){
logxy = aux_log(x, y)
return(sqrt(sum(logxy^2)))
}
return(apply(maty, 1, dist_one))
}
library(RiemBase)
mymu  = rnorm(myp)
mymu  = mymu/sqrt(sum(mymu^2))
myx   = RiemSphere::rspnorm(myn, mymu, lambda=mylbd)
mymean = as.vector(rbase.mean(riemfactory(t(myx), name="sphere"))$x)
dspnorm.constant <- function(lbd, D){ # lbd : lambda / D : dimension
myfunc <- function(r){
return(exp(-lbd*(r^2)/2)*((sin(r))^(D-2)))
}
t1 = 2*(pi^((D-1)/2))/gamma((D-1)/2) # one possible source of error
t2 = stats::integrate(myfunc, lower=0, upper=pi, rel.tol=sqrt(.Machine$double.eps))$value
return(t1*t2)
}
C = sum(aux_dist_1toN(mymean, myx)^2)
D = ncol(myx)
n = nrow(myx)
# test 1. shape of log-likelihood function --------------------------------
vec.lambda = seq(from=0,to=20,length.out=200)
vec.cost   = rep(0,length(vec.lambda))
for (i in 1:length(vec.lambda)){
tl = vec.lambda[i]
term1 = -(tl/2)*C
term2 = -n*log(dspnorm.constant(tl,D))
vec.cost[i] = term1+term2
}
lopt = vec.lambda[which.max(vec.cost)]
hey = mle.spnorm(myx)
plot(vec.lambda, vec.cost, main="red-MLE, blue-TRUE")
abline(v=hey$method3, lwd=2, col="red")
abline(v=mylbd, lwd=2, col="blue")
library(ggplot2)
library(microbenchmark)  # time comparison of multiple methods
lbdtime <- microbenchmark(
deoptim = mle.spnorm(myx, method=1),
statopt = mle.spnorm(myx, method=2),
newtons = mle.spnorm(myx, method=3), times=20L
)
autoplot(lbdtime)
myp   = 5
mylbd = stats::runif(1, min=0.0001, max=15)
myn   = 2000
aux_log <- function(mu, x){
theta = base::acos(sum(x*mu))
if (abs(theta)<sqrt(.Machine$double.eps)){
output = x-mu*(sum(x*mu))
} else {
output = (x-mu*(sum(x*mu)))*theta/sin(theta)
}
return(output)
}
check_single <- function(x){
return(sum(x^2))
}
aux_dist_1toN <- function(x, maty){
dist_one <- function(y){
logxy = aux_log(x, y)
return(sqrt(sum(logxy^2)))
}
return(apply(maty, 1, dist_one))
}
library(RiemBase)
mymu  = rnorm(myp)
mymu  = mymu/sqrt(sum(mymu^2))
myx   = RiemSphere::rspnorm(myn, mymu, lambda=mylbd)
mymean = as.vector(rbase.mean(riemfactory(t(myx), name="sphere"))$x)
dspnorm.constant <- function(lbd, D){ # lbd : lambda / D : dimension
myfunc <- function(r){
return(exp(-lbd*(r^2)/2)*((sin(r))^(D-2)))
}
t1 = 2*(pi^((D-1)/2))/gamma((D-1)/2) # one possible source of error
t2 = stats::integrate(myfunc, lower=0, upper=pi, rel.tol=sqrt(.Machine$double.eps))$value
return(t1*t2)
}
C = sum(aux_dist_1toN(mymean, myx)^2)
D = ncol(myx)
n = nrow(myx)
# test 1. shape of log-likelihood function --------------------------------
vec.lambda = seq(from=0,to=20,length.out=200)
vec.cost   = rep(0,length(vec.lambda))
for (i in 1:length(vec.lambda)){
tl = vec.lambda[i]
term1 = -(tl/2)*C
term2 = -n*log(dspnorm.constant(tl,D))
vec.cost[i] = term1+term2
}
lopt = vec.lambda[which.max(vec.cost)]
hey = mle.spnorm(myx)
plot(vec.lambda, vec.cost, main="red-MLE, blue-TRUE")
abline(v=hey$method3, lwd=2, col="red")
abline(v=mylbd, lwd=2, col="blue")
# test 2. time comparison for concentration estimation algorithms ---------
library(ggplot2)
library(microbenchmark)  # time comparison of multiple methods
lbdtime <- microbenchmark(
deoptim = mle.spnorm(myx, method=1),
statopt = mle.spnorm(myx, method=2),
newtons = mle.spnorm(myx, method=3), times=20L
)
autoplot(lbdtime)
# test 3. estimation over iterations --------------------------------------
rec.dir <- rep(0,myn-1)
rec.lbd <- rep(0,myn-1)
for (i in 1:(myn-1)){
tgtmle = mle.spnorm(myx[1:(i+1),])
tgt.mean = tgtmle$mu
tgt.lbd  = tgtmle$lambda
rec.dir[i] = sqrt(sum((mymu-tgt.mean)^2))
rec.lbd[i] = tgt.lbd
}
help(sort)
ttfun <- function(x){return(2*x)}
vecfun = rnorm(5)
apply(vecfun, ttfun)
apply(vecfun, 1, ttfun)
apply(vecfun, 0, ttfun)
help(apply)
apply(matrix(vecfun), 1, ttfun)
library(RiemSphere)
rec.dir <- rep(0,myn-1)
rec.lbd <- rep(0,myn-1)
for (i in 1:(myn-1)){
tgtmle = mle.spnorm(myx[1:(i+1),])
tgt.mean = tgtmle$mu
tgt.lbd  = tgtmle$lambda
rec.dir[i] = sqrt(sum((mymu-tgt.mean)^2))
rec.lbd[i] = tgt.lbd
print(paste("iteration ",i," complete..",sep=""))
}
x11()
par(mfrow=c(1,2))
plot(2:myn, rec.dir, "b", cex=2, main="evolution : mean direction")
plot(2:myn, rec.lbd, "b", cex=2, main="evolution : concentration")
selectid = round(seq(from=2,to=myn,length.out=100))-1
xid      = 2:myn
x11()
par(mfrow=c(1,2))
plot(xid[selectid], rec.dir[selectid], "b", cex=2, main="evolution : mean direction")
plot(xid[selectid], rec.lbd[selectid], "b", cex=2, main="evolution : concentration")
library(RiemSphere)
myp   = 5
mylbd = stats::runif(1, min=0.0001, max=15)
myn   = 2000
aux_log <- function(mu, x){
theta = base::acos(sum(x*mu))
if (abs(theta)<sqrt(.Machine$double.eps)){
output = x-mu*(sum(x*mu))
} else {
output = (x-mu*(sum(x*mu)))*theta/sin(theta)
}
return(output)
}
check_single <- function(x){
return(sum(x^2))
}
aux_dist_1toN <- function(x, maty){
dist_one <- function(y){
logxy = aux_log(x, y)
return(sqrt(sum(logxy^2)))
}
return(apply(maty, 1, dist_one))
}
library(RiemBase)
mymu  = rnorm(myp)
mymu  = mymu/sqrt(sum(mymu^2))
myx   = RiemSphere::rspnorm(myn, mymu, lambda=mylbd)
mymean = as.vector(rbase.mean(riemfactory(t(myx), name="sphere"))$x)
dspnorm.constant <- function(lbd, D){ # lbd : lambda / D : dimension
myfunc <- function(r){
return(exp(-lbd*(r^2)/2)*((sin(r))^(D-2)))
}
t1 = 2*(pi^((D-1)/2))/gamma((D-1)/2) # one possible source of error
t2 = stats::integrate(myfunc, lower=0, upper=pi, rel.tol=sqrt(.Machine$double.eps))$value
return(t1*t2)
}
C = sum(aux_dist_1toN(mymean, myx)^2)
D = ncol(myx)
n = nrow(myx)
# test 1. shape of log-likelihood function --------------------------------
vec.lambda = seq(from=0,to=20,length.out=200)
vec.cost   = rep(0,length(vec.lambda))
for (i in 1:length(vec.lambda)){
tl = vec.lambda[i]
term1 = -(tl/2)*C
term2 = -n*log(dspnorm.constant(tl,D))
vec.cost[i] = term1+term2
}
lopt = vec.lambda[which.max(vec.cost)]
hey = mle.spnorm(myx)
plot(vec.lambda, vec.cost, main="red-MLE, blue-TRUE")
abline(v=hey$method3, lwd=2, col="red")
abline(v=mylbd, lwd=2, col="blue")
# test 2. time comparison for concentration estimation algorithms ---------
x11()
library(ggplot2)
library(microbenchmark)  # time comparison of multiple methods
lbdtime <- microbenchmark(
deoptim = mle.spnorm(myx, method=1),
statopt = mle.spnorm(myx, method=2),
newtons = mle.spnorm(myx, method=3), times=20L
)
autoplot(lbdtime)
# test 3. estimation over iterations --------------------------------------
rec.dir <- rep(0,myn-1)
rec.lbd <- rep(0,myn-1)
for (i in 1:(myn-1)){
tgtmle = mle.spnorm(myx[1:(i+1),])
tgt.mean = tgtmle$mu
tgt.lbd  = tgtmle$lambda
rec.dir[i] = sqrt(sum((mymu-tgt.mean)^2))
rec.lbd[i] = tgt.lbd
print(paste("iteration ",i," complete..",sep=""))
}
selectid = round(seq(from=2,to=myn,length.out=100))-1
xid      = 2:myn
x11()
par(mfrow=c(1,2))
plot(xid[selectid], rec.dir[selectid], "b", cex=2, main="evolution : mean direction")
plot(xid[selectid], rec.lbd[selectid], "b", cex=2, main=paste("evolution : concentration with ", mylbd,sep=""))
x11()
par(mfrow=c(1,2))
plot(xid[selectid], rec.dir[selectid], "b", cex=0.5, main="evolution : mean direction")
plot(xid[selectid], rec.lbd[selectid], "b", cex=0.5, main="evolution : concentration")
abline(h=mylbd, col="red")
abline(h=mylbd, col="red", lwd=1.5)
plot(xid[selectid], rec.lbd[selectid], "b", cex=0.5, main="evolution : concentration")
abline(h=mylbd, col="red", lwd=1.5)
par(mfrow=c(1,2))
plot(xid[selectid], rec.dir[selectid], "b", cex=0.5, main="evolution : mean direction")
abline(h=0, col="blue", lwd=2)
plot(xid[selectid], rec.lbd[selectid], "b", cex=0.5, main="evolution : concentration")
abline(h=mylbd, col="red", lwd=1.5)
library(RiemSphere)
