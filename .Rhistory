rec.lbd[i] = tgt.lbd
print(paste("iteration ",i," complete..",sep=""))
}
selectid = round(seq(from=2,to=myn,length.out=100))-1
xid      = 2:myn
x11()
par(mfrow=c(1,2))
plot(xid[selectid], rec.dir[selectid], "b", cex=2, main="evolution : mean direction")
plot(xid[selectid], rec.lbd[selectid], "b", cex=2, main=paste("evolution : concentration with ", mylbd,sep=""))
x11()
par(mfrow=c(1,2))
plot(xid[selectid], rec.dir[selectid], "b", cex=0.5, main="evolution : mean direction")
plot(xid[selectid], rec.lbd[selectid], "b", cex=0.5, main="evolution : concentration")
abline(h=mylbd, col="red")
abline(h=mylbd, col="red", lwd=1.5)
plot(xid[selectid], rec.lbd[selectid], "b", cex=0.5, main="evolution : concentration")
abline(h=mylbd, col="red", lwd=1.5)
par(mfrow=c(1,2))
plot(xid[selectid], rec.dir[selectid], "b", cex=0.5, main="evolution : mean direction")
abline(h=0, col="blue", lwd=2)
plot(xid[selectid], rec.lbd[selectid], "b", cex=0.5, main="evolution : concentration")
abline(h=mylbd, col="red", lwd=1.5)
library(RiemSphere)
library(RiemSphere)
x = rnorm(5)
d = length(x)
output = x[2:length(x)]/x[1]
output
project.stereo.single <- function(x){
d = length(x)
output = x[2:length(x)]/(1-x[1])
return(output)
}
project.invstereo.single <- function(x){
S2 = sum(x^2)
return(c(((S2-1)/(S2+1)),((2*x)/(S2+1))))
}
x = rnorm(5)
x = x/sqrt(sum(x^2))
y = project.stereo.single(x)
z = project.invstereo.single(y)
x
z
library(RiemSphere)
library(RiemSphere)
rm(list=ls())
library(RiemSphere)
A = rvmf(100, c(0,0,1), 1)
A
c(0,0,1)
xx = c(0,0,1)
sum(xx^2)
A = rvmf(100, xx, 1)
A
A = rvmf(100, xx+1, 1)
A = rvmf(100, xx, 1)
library(Directional)
Directional::rvmf(100, xx, 1)
Directional::rvmf(100, c(1,0,0), 1)
Directional::rvmf(100, c(0,0,1), 1)
help(rvmf)
library(RiemSphere)
library(Rfast)
help(mediandir)
help("matrnorm")
x <- matrnorm(100, 100)
mean(x)
sd(x)
help("rowsums")
x <- matrix(rpois(500 * 100, 10),ncol = 100)
Rfast::rowsums(x)
base::rowsum(x)
base::rowSums(x)
help(tcrossprod)
rvmf_uniform <- function(n, mu, k=0){
d = length(mu)
x1 = matrix(rnorm(n*d),nrow=n)
x  = x1/sqrt(base::rowSums(x1^2))
return(x)
}
rvmf_uniform(10, c(0,0,1))
AA = rvmf_uniform(10, c(0,0,1))
AA[1,]
sum(AA[1,]^2)
library(RiemSphere)
library(RiemSphere)
A = RiemSphere::rvmf(100, c(0,0,1), kappa=1)
A
checker_single <- function(x){return(sum(x^2))}
apply(A,1,checker_single)
library(RiemSphere)
library(RiemSphere)
A = rvmf(100, c(0,0,1), k=10)
Directional::vmf(A)
A
A = RiemSphere::rvmf(100, c(0,0,1), k=10)
A
A = RiemSphere::rvmf(100, c(0,0,1), k=10)
Directional::vmf(A)
aux_rotation <- function(a, b) {
p <- length(a)
ab <- sum(a * b)
ca <- a - b * ab
ca <- ca/sqrt(sum(ca^2))
A <- b %*% t(ca)
A <- A - t(A)
theta <- acos(ab)
diag(p) + sin(theta) * A + (cos(theta) - 1) * (b %*%
t(b) + ca %*% t(ca))
}
a = as.vector(A[1,])
b = as.vector(A[2,])
myr = aux_rotation(a,b)
a
myr%*%a
b
library(RiemSphere)
library(RiemSphere)
rm(list=ls())
Directional::rvmf(10,c(0,0,1),1)
RiemSphere::rvmf(10,c(0,0,1),1)
library(RiemSphere)
library(RiemSphere)
library(RiemSphere)
library(RiemSphere)
#
# TESTER FOR MLE ESTIMATION -----------------------------------------------
myp   = 5
mylbd = stats::runif(1, min=0.0001, max=15)
myn   = 2000
aux_log <- function(mu, x){
theta = base::acos(sum(x*mu))
if (abs(theta)<sqrt(.Machine$double.eps)){
output = x-mu*(sum(x*mu))
} else {
output = (x-mu*(sum(x*mu)))*theta/sin(theta)
}
return(output)
}
check_single <- function(x){
return(sum(x^2))
}
aux_dist_1toN <- function(x, maty){
dist_one <- function(y){
logxy = aux_log(x, y)
return(sqrt(sum(logxy^2)))
}
return(apply(maty, 1, dist_one))
}
library(RiemBase)
mymu  = rnorm(myp)
mymu  = mymu/sqrt(sum(mymu^2))
myx   = RiemSphere::rspnorm(myn, mymu, lambda=mylbd)
mymean = as.vector(rbase.mean(riemfactory(t(myx), name="sphere"))$x)
dspnorm.constant <- function(lbd, D){ # lbd : lambda / D : dimension
myfunc <- function(r){
return(exp(-lbd*(r^2)/2)*((sin(r))^(D-2)))
}
t1 = 2*(pi^((D-1)/2))/gamma((D-1)/2) # one possible source of error
t2 = stats::integrate(myfunc, lower=0, upper=pi, rel.tol=sqrt(.Machine$double.eps))$value
return(t1*t2)
}
C = sum(aux_dist_1toN(mymean, myx)^2)
D = ncol(myx)
n = nrow(myx)
# test 1. shape of log-likelihood function --------------------------------
vec.lambda = seq(from=0,to=20,length.out=200)
vec.cost   = rep(0,length(vec.lambda))
for (i in 1:length(vec.lambda)){
tl = vec.lambda[i]
term1 = -(tl/2)*C
term2 = -n*log(dspnorm.constant(tl,D))
vec.cost[i] = term1+term2
}
lopt = vec.lambda[which.max(vec.cost)]
hey = mle.spnorm(myx)
plot(vec.lambda, vec.cost, main="red-MLE, blue-TRUE")
abline(v=hey$method3, lwd=2, col="red")
abline(v=mylbd, lwd=2, col="blue")
# test 2. time comparison for concentration estimation algorithms ---------
x11()
library(ggplot2)
library(microbenchmark)  # time comparison of multiple methods
lbdtime <- microbenchmark(
deoptim = mle.spnorm(myx, method=1),
statopt = mle.spnorm(myx, method=2),
newtons = mle.spnorm(myx, method=3), times=20L
)
autoplot(lbdtime)
# test 3. estimation over iterations --------------------------------------
rec.dir <- rep(0,myn-1)
rec.lbd <- rep(0,myn-1)
for (i in 1:(myn-1)){
tgtmle = mle.spnorm(myx[1:(i+1),])
tgt.mean = tgtmle$mu
tgt.lbd  = tgtmle$lambda
rec.dir[i] = sqrt(sum((mymu-tgt.mean)^2))
rec.lbd[i] = tgt.lbd
print(paste("iteration ",i," complete..",sep=""))
}
x11()
library(ggplot2)
library(microbenchmark)  # time comparison of multiple methods
lbdtime <- microbenchmark(
deoptim = mle.spnorm(myx, method=1),
statopt = mle.spnorm(myx, method=2),
newton1 = mle.spnorm(myx, method=3),
newton2 = mle.spnorm(myx, method=4), times=20L
)
autoplot(lbdtime)
myx
dim(myx)
mle.spnorm(myx, method=4)
library(RiemSphere)
mle.spnorm(myx, method=4)
library(RiemSphere)
mle.spnorm(myx, method=4)
mle.spnorm(myx, method=4)
mle.spnorm(myx, method=4)
mle.spnorm(myx, method=3)
mle.spnorm(myx, method=2)
mle.spnorm(myx, method=1)
mle.spnorm(myx, method=3)
library(RiemSphere)
mle.spnorm(myx, method=3)
mle.spnorm(myx, method=4)
library(RiemSphere)
mle.spnorm(myx, method=4)
mle.spnorm(myx, method=3)
library(RiemSphere)
mle.spnorm(myx, method=3)
library(RiemSphere)
mle.spnorm(myx, method=3)
mle.spnorm(myx, method=3)
myp   = 5
mylbd = stats::runif(1, min=0.0001, max=15)
myn   = 2000
mymu  = rnorm(myp)
mymu  = mymu/sqrt(sum(mymu^2))
myx   = RiemSphere::rspnorm(myn, mymu, lambda=mylbd)
mle.spnorm(myx, method=1)
mle.spnorm(myx, method=2)
mle.spnorm(myx, method=3)
myp   = 5
mylbd = stats::runif(1, min=0.0001, max=15)
myn   = 2000
mymu  = rnorm(myp)
mymu  = mymu/sqrt(sum(mymu^2))
myx   = RiemSphere::rspnorm(myn, mymu, lambda=mylbd)
mle.spnorm(myx, method=1)
mle.spnorm(myx, method=2)
mle.spnorm(myx, method=3)
myp   = 5
mylbd = stats::runif(1, min=0.0001, max=15)
myn   = 2000
mymu  = rnorm(myp)
mymu  = mymu/sqrt(sum(mymu^2))
myx   = RiemSphere::rspnorm(myn, mymu, lambda=mylbd)
mle.spnorm(myx, method=1)
mle.spnorm(myx, method=2)
mle.spnorm(myx, method=3)
library(ggplot2)
library(microbenchmark)  # time comparison of multiple methods
lbdtime <- microbenchmark(
deoptim = mle.spnorm(myx, method=1),
statopt = mle.spnorm(myx, method=2),
newton1 = mle.spnorm(myx, method=3), times=20L
)
autoplot(lbdtime)
library(RiemSphere)
myp   = 5
mylbd = stats::runif(1, min=0.0001, max=15)
myn   = 2000
mymu  = rnorm(myp)
mymu  = mymu/sqrt(sum(mymu^2))
myx   = RiemSphere::rspnorm(myn, mymu, lambda=mylbd)
mle.spnorm(myx, method=1)
mle.spnorm(myx, method=2)
mle.spnorm(myx, method=3)
library(ggplot2)
library(microbenchmark)  # time comparison of multiple methods
lbdtime <- microbenchmark(
deoptim = mle.spnorm(myx, method=1),
statopt = mle.spnorm(myx, method=2),
newton1 = mle.spnorm(myx, method=3), times=20L
)
autoplot(lbdtime)
autoplot(lbdtime)
graphics.off()
autoplot(lbdtime)
dev.off()
autoplot(lbdtime)
mle.spnorm(myx, method=1)
mle.spnorm(myx, method=2)
mle.spnorm(myx, method=3)
library(cluster)
help("silhouette")
data(ruspini)
pr4 <- pam(ruspini, 4)
pr4
help(pam)
help(ruspini)
# COMPARE THREE METHODS
myp   = 5
mylbd = stats::runif(1, min=0.0001, max=15)
myn   = 2000
mymu  = rnorm(myp)
mymu  = mymu/sqrt(sum(mymu^2))
myx   = RiemSphere::rspnorm(myn, mymu, lambda=mylbd)
mle.spnorm(myx, method=1)
mle.spnorm(myx, method=2)
mle.spnorm(myx, method=3)
library(ggplot2)
library(microbenchmark)  # time comparison of multiple methods
dev.off()
lbdtime <- microbenchmark(
deoptim = mle.spnorm(myx, method=1),
statopt = mle.spnorm(myx, method=2),
newton1 = mle.spnorm(myx, method=3), times=20L
)
autoplot(lbdtime)
library(RiemSphere)
# COMPARE THREE METHODS
myp   = 5
mylbd = stats::runif(1, min=0.0001, max=15)
myn   = 2000
mymu  = rnorm(myp)
mymu  = mymu/sqrt(sum(mymu^2))
myx   = RiemSphere::rspnorm(myn, mymu, lambda=mylbd)
mle.spnorm(myx, method=1)
mle.spnorm(myx, method=2)
mle.spnorm(myx, method=3)
library(ggplot2)
library(microbenchmark)  # time comparison of multiple methods
dev.off()
lbdtime <- microbenchmark(
deoptim = mle.spnorm(myx, method=1),
statopt = mle.spnorm(myx, method=2),
newton1 = mle.spnorm(myx, method=3), times=20L
)
autoplot(lbdtime)
library(RiemSphere)
x = c(0.01,0.015,0.02,0.025,0.03)
p.adjust(x, method="BH")
p.adjust(c(x, 0.055, 0.066, 0.077), method="BH")
help("p.adjust")
mytry <- function(ps){
ordps = order(ps)
ordered = sort(ps, decreasing = FALSE)
m = length(ordered)
ordout = ordered*(m/(1:m))
return(ordout[ordps])
}
mytry(c(x, 0.055, 0.066, 0.077))
mytry <- function(ps){
ordps = order(ps)
ordered = sort(ps, decreasing = FALSE)
m = length(ordered)
ordout = ordered*((1:m)/m)
return(ordout[ordps])
}
mytry(c(x, 0.055, 0.066, 0.077))
mytry <- function(ps){
ordps = order(ps)
ordered = sort(ps, decreasing = FALSE)
m = length(ordered)
ordout = ordered*(m/(1:m))
return(ordout[ordps])
}
y = c(x, 0.055, 0.066, 0.077)
p.adjust(mytry, method="BH")
p.adjust(y, method="BH")
mytry(y)
z = y(sample(1:length(y),length(y))
)
z = y[sample(1:length(y),length(y))]
p.adjust(z, method="BH")
mytry(z)
mytry <- function(ps){
ordps = order(ps)
ordered = sort(ps, decreasing = FALSE)
m = length(ordered)
ordout = ordered*(m/(1:m))
return(ordout[ordps])
}
mytry(z)
order(z)
z[order(z)]
zz = sort(z, decreasing = FALSE)
zz[order(z)]
z
help(order)
zz[rank(z)]
z
mytry <- function(ps){
ordps = rank(ps)
ordered = sort(ps, decreasing = FALSE)
m = length(ordered)
ordout = ordered*(m/(1:m))
return(ordout[ordps])
}
mytry(zz)
p.adjust(zz, method="BH")
ps = z
alpha = 0.05
ordps = rank(ps)
ordered = sort(ps, decreasing = FALSE)
m = length(ordered)
k = which.max(ordered <= ((1:m)/m)*alpha)
mytry2 <- function(ps){
alpha = 0.05
ordps = rank(ps)
ordered = sort(ps, decreasing = FALSE)
m = length(ordered)
k = which.max(ordered <= ((1:m)/m)*alpha)
ordout = ordered
ordout[1:k] = ordout[1:k]*(m/(1:k))
return(ordout[ordps])
}
p.adjust(zz, method="BH")
mytry(zz)
mytry2(zz)
mytry2 <- function(ps){
alpha = 0.05
ordps = rank(ps)
ordered = sort(ps, decreasing = FALSE)
m = length(ordered)
k = which.max(ordered <= ((1:m)/m)*alpha)
ordout = ordered
ordout[(k+1):m] = ordout[(k+1):m]*(m/((k+1):m))
return(ordout[ordps])
}
mytry2(zz)
alpha = 0.05
ordps = rank(ps)
ordered = sort(ps, decreasing = FALSE)
m = length(ordered)
k = which.max(ordered <= ((1:m)/m)*alpha)
k
k = which.max(ordered <= ((1:m)/m)*alpha)
ordout = ordered
ordout[1:k] = 0
ordout[ordps]
p.adjust(zz, method="BH")
ordout = ordered
ordout[(k+1):m] = 0
ordout[ordps]
alpha = 0.05
ordps = rank(ps)
ps = z
alpha = 0.05
ordps = rank(ps)
ordered = sort(ps, decreasing = FALSE)
m = length(ordered)
k = which.max(ordered <= ((1:m)/m)*alpha)
ordout = ordered
ordout[(k+1):m] = 0
ordout[ordps]
ordout = ordered
ordout[1:k] = 0
ordout[ordps]
plot(1:8, ordps)
plot(1:8, ordps, "l")
plot(1:8, ordps, "b")
plot(1:8, ordout[ordps], "b")
par(mfrow=c(1,2))
plot(1:8, ordout[ordps], "b")
plot(1:8, p.adjust(ps, method="BH"))
plot(1:8, p.adjust(ps, method="BH"), "b")
plot(1:8, p.adjust(ps, method="BH"), "b")
plot(1:8, ordout[ordps], "b")
plot(1:8, p.adjust(ps, method="BH"), "b")
plot(1:8, ordout[ordps], "b", ylim=c(0,0.08))
plot(1:8, p.adjust(ps, method="BH"), "b", ylim=c(0,0.08))
ordout[ordps]
install.packages(c("DEoptim","RiemBase"), dependencies = TRUE)
rm(list=ls())
library(RiemSphere)
devtools::document()
library(RiemSphere)
library(RiemSphere)
library(RiemSphere)
aux_log <- function(mu, x){
# theta = base::acos(sum(x*mu))
theta = tryCatch({base::acos(sum(x*mu))},
warning=function(w){
0
},error=function(e){
0
})
if (abs(theta)<10*(.Machine$double.eps)){
output = x-mu*(sum(x*mu))
} else {
output = (x-mu*(sum(x*mu)))*theta/sin(theta)
}
return(output)
}
x = Directional::rvmf(2, c(1,0,0), 2)
x1 = as.vector(x[1,])
x2 = as.vector(x[2,])
sqrt(sum(aux_log(x1,x2)^2))
acos(sum(x1*x2))
1-sum(x1*x2)/(sqrt(sum(x1^2))*sqrt(sum(x2^2)))
sum(x1*x2)/(sqrt(sum(x1^2))*sqrt(sum(x2^2)))
library(skmenas)
library(skmeans)
??skmeans
help(skmeans)
acos(sum(x1*x2))
1-sum(x1*x2)
library(RiemSphere)
library(RiemSphere)
