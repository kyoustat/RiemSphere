library(RiemSphere)
library(RiemSphere)
library(RiemSphere)
devtools::document()
help(rvmf)
help(rnorm)
help(rchisq)
x <- rvmf(60, rnorm(3), 15)ina <- rep(1:3, each = 20)hcf.aov(x, ina)hcf.aov(x, ina, fc = FALSE)lr.aov(x, ina)embed.aov(x, ina)het.aov(x, ina)
help(embed.aov)
library(Directional)
help(embed.aov)
library(RiemSphere)
help(toBar)
library(RiemSphere)
help("alsoToBar")
help(rnorm)
library(RiemSphere)
library(RiemSphere)
library(RiemSphere)
warning()
warnings()
library(RiemSphere)
library(RiemSphere)
library(RiemSphere)
library(RiemSphere)
library(RiemSphere)
help("againToBar")
help(rnorm)
help("againToBar")
help(rnorm)
library(RiemSphere)
devtools::document()
library(RiemSphere)
help("alsoTheQuestion")
help(rnorm)
library(RiemSphere)
help("alsoToBar"
)
help("theQuestion")
library(RiemSphere)
library(RiemSphere)
help(alsoNotToBar)
library(RiemSphere)
devtools::document()
library(RiemSphere)
help("againToBar")
library(RiemSphere)
help("againToBar")
library(RiemSphere)
help(rnorm)
library(RiemSphere)
help(dspnorm)
help(rnorm)
library(RiemSphere)
library(RiemSphere)
help(rspnorm)
help(spnorm)
!(1==2)
check_num_nonneg <- function(x){
cond1 = (length(x)==1)
cond2 = ((is.finite(x))&&(!is.na(x))&&(x>0))
if (cond1&&cond2){
return(TRUE)
} else {
stop(paste("* ",deparse(substitute(x))," is not a nonnegative number.",sep=""))
}
}
myi = -10
check_num_nonneg(myi)
check_num_nonneg <- function(x){
cond1 = (length(x)==1)
cond2 = ((is.finite(x))&&(!is.na(x))&&(x>0))
if (cond1&&cond2){
return(TRUE)
} else {
stop(paste("* '",deparse(substitute(x)),"' is not a nonnegative number.",sep=""))
}
}
check_num_nonneg(myi)
help(mvtnorm)
Lambda = diag(5)*3
II = 1.2*diag(5)
Lambda
II
Precision = (Lambda + II)
Precision
solve(Precision)
help(rnorm)
rspnorm.single <- function(lambda, D){
status = TRUE
sqrts  = sqrt(1/(lambda + ((D-2)/pi)))
while (status==TRUE){
v = stats::rnorm(D,mean = 0, sd=sqrts)
v.norm = sqrt(sum(v^2))
if (v.norm <= pi){
if (v.norm <= sqrt(.Machine$double.eps)){
r1 = exp(-(lambda/2)*(v.norm^2))
} else {
r1 = exp(-(lambda/2)*(v.norm^2))*((sin(v.norm)/v.norm)^(D-2))
}
r2 = exp(-((v.norm^2)/2)*(lambda+((D-2)/pi)))
}
r = r1/r2
u = stats::runif(1)
if (u <= r){
status = FALSE
}
}
return(v)
}
rspnorm.single(1,2)
rspnorm.single(1,3)
rspnorm.single(1,4)
x = rspnorm.single(1,4)
sum(x^2)
aux_log <- function(mu, x){
theta = base::acos(sum(x*mu))
if (abs(theta)<sqrt(.Machine$double.eps)){
output = x-mu*(sum(x*mu))
} else {
output = (x-mu*(sum(x*mu)))*theta/sin(theta)
}
return(output)
}
aux_exp <- function(my, v){
norm.v = sqrt(sum(v^2))
if (norm.v < sqrt(.Machine$double.eps)){
output = mu*cos(norm.v) + v
} else {
output = mu*cos(norm.v) + (sin(norm.v)/norm.v)*v
}
return(output)
}
x = rnorm(3)
y = rnorm(3)
x = x/sqrt(sum(x^2))
y = y/sqrt(sum(y^2))
aux_exp(x, aux_log(x,y))
aux_exp <- function(mu, v){
norm.v = sqrt(sum(v^2))
if (norm.v < sqrt(.Machine$double.eps)){
output = mu*cos(norm.v) + v
} else {
output = mu*cos(norm.v) + (sin(norm.v)/norm.v)*v
}
return(output)
}
aux_exp(x, aux_log(x,y))
y
y
aux_log(x,y)
rm(list=ls())
library(RiemSphere)
library(RiemSphere)
library(RiemSphere)
library(RiemSphere)
# 2. test my package of 'RiemSphere' --------------------------------------
library(RiemSphere)
library(RiemSphere)
help("dspnorm")
help(rspnorm)
help(rnorm)
help(dspnorm)
help(rspnorm)
library(RiemSphere)
library(RiemSphere)
help("rspnorm")
library(RiemSphere)
help(spnorm)
help("rspnorm")
help("dspnorm")
library(RiemSphere)
help(rspnorm)
rspnorm(1, c(0,0,1))
library(RiemSphere)
# 2. test my package of 'RiemSphere' --------------------------------------
library(RiemSphere)
# MC integration of spherical normal distribution -------------------------
# now it works, don't know why but somehow, yeah !
rm(list=ls())
graphics.off()
library(Rfast)
# parameters --------------------------------------------------------------
p = 10
n = 123456
lambda = abs(rnorm(n=1,mean=0,sd=5)) # if (p,kap)=(10,6.7), convergence is very slow, but still it does.
mu = rnorm(p)
mu = mu/sqrt(sum(mu^2))
samples = rvmf(n, mu, 0)       # 'Rfast' package
func.nconstant <- function(lbd, D){ # lbd : lambda / D : dimension
myfunc <- function(r){
return(exp(-lbd*(r^2)/2)*((sin(r))^(D-2)))
}
t1 = 2*(pi^((D-1)/2))/gamma((D-1)/2) # one possible source of error
t2 = stats::integrate(myfunc, lower=0, upper=pi, rel.tol=sqrt(.Machine$double.eps))$value
return(t1*t2)
}
splog <- function(par.mu, par.x){
xmu = sum(par.x*par.mu)
theta = acos(xmu)
if (abs(theta)<sqrt(.Machine$double.eps)){
output = par.x-(par.mu*xmu)
} else {
output = (par.x-(par.mu*xmu))*(theta/sin(theta))
}
return(output)
}
# 1. MC integration of von-Mises Fisher distribution on sphere ------------
Cpk    = func.nconstant(lambda, p)
uscale =2*(pi^(p/2))/gamma(p/2)
svec = rep(0,n)
for (i in 1:n){
logmux = splog(mu, as.vector(samples[i,]))
svec[i] = exp(-(lambda/2)*sum(logmux*logmux))
}
numerator = cumsum(svec) # unscaled only
xx = 1:n
yy = (numerator/xx)*uscale
ymin = min(mean(yy)-sd(yy),0.9)
ymax = max(mean(yy)+sd(yy),1.1)
par(mfrow=c(1,2))
plot(xx,yy,"l",main=paste("normalizing constant with kappa=",round(lambda,digits=2),sep=""))
abline(h=Cpk,col="red",lwd=2) # horizontal line of normalizing constant
# 2. test my package of 'RiemSphere' --------------------------------------
library(RiemSphere)
yy2 = dspnorm(samples, mu, lambda = lambda)
plot(xx,yy2,"l")
yy2
is.vector(samples)
library(RiemSphere)
# MC integration of spherical normal distribution -------------------------
# now it works, don't know why but somehow, yeah !
rm(list=ls())
graphics.off()
library(Rfast)
# parameters --------------------------------------------------------------
p = 10
n = 123456
lambda = abs(rnorm(n=1,mean=0,sd=5)) # if (p,kap)=(10,6.7), convergence is very slow, but still it does.
mu = rnorm(p)
mu = mu/sqrt(sum(mu^2))
samples = rvmf(n, mu, 0)       # 'Rfast' package
func.nconstant <- function(lbd, D){ # lbd : lambda / D : dimension
myfunc <- function(r){
return(exp(-lbd*(r^2)/2)*((sin(r))^(D-2)))
}
t1 = 2*(pi^((D-1)/2))/gamma((D-1)/2) # one possible source of error
t2 = stats::integrate(myfunc, lower=0, upper=pi, rel.tol=sqrt(.Machine$double.eps))$value
return(t1*t2)
}
splog <- function(par.mu, par.x){
xmu = sum(par.x*par.mu)
theta = acos(xmu)
if (abs(theta)<sqrt(.Machine$double.eps)){
output = par.x-(par.mu*xmu)
} else {
output = (par.x-(par.mu*xmu))*(theta/sin(theta))
}
return(output)
}
# 1. MC integration of von-Mises Fisher distribution on sphere ------------
Cpk    = func.nconstant(lambda, p)
uscale =2*(pi^(p/2))/gamma(p/2)
svec = rep(0,n)
for (i in 1:n){
logmux = splog(mu, as.vector(samples[i,]))
svec[i] = exp(-(lambda/2)*sum(logmux*logmux))
}
numerator = cumsum(svec) # unscaled only
xx = 1:n
yy = (numerator/xx)*uscale
ymin = min(mean(yy)-sd(yy),0.9)
ymax = max(mean(yy)+sd(yy),1.1)
par(mfrow=c(1,2))
plot(xx,yy,"l",main=paste("normalizing constant with kappa=",round(lambda,digits=2),sep=""))
abline(h=Cpk,col="red",lwd=2) # horizontal line of normalizing constant
# 2. test my package of 'RiemSphere' --------------------------------------
library(RiemSphere)
yy2.vec = dspnorm(samples, mu, lambda = lambda)
yy2     = cumsum(yy2.vec)/xx*uscale
plot(xx,yy2,"l")
# MC integration of spherical normal distribution -------------------------
# now it works, don't know why but somehow, yeah !
rm(list=ls())
graphics.off()
library(Rfast)
# parameters --------------------------------------------------------------
p = 10
n = 123456
lambda = abs(rnorm(n=1,mean=0,sd=5)) # if (p,kap)=(10,6.7), convergence is very slow, but still it does.
mu = rnorm(p)
mu = mu/sqrt(sum(mu^2))
samples = rvmf(n, mu, 0)       # 'Rfast' package
func.nconstant <- function(lbd, D){ # lbd : lambda / D : dimension
myfunc <- function(r){
return(exp(-lbd*(r^2)/2)*((sin(r))^(D-2)))
}
t1 = 2*(pi^((D-1)/2))/gamma((D-1)/2) # one possible source of error
t2 = stats::integrate(myfunc, lower=0, upper=pi, rel.tol=sqrt(.Machine$double.eps))$value
return(t1*t2)
}
splog <- function(par.mu, par.x){
xmu = sum(par.x*par.mu)
theta = acos(xmu)
if (abs(theta)<sqrt(.Machine$double.eps)){
output = par.x-(par.mu*xmu)
} else {
output = (par.x-(par.mu*xmu))*(theta/sin(theta))
}
return(output)
}
# 1. MC integration of von-Mises Fisher distribution on sphere ------------
Cpk    = func.nconstant(lambda, p)
uscale =2*(pi^(p/2))/gamma(p/2)
svec = rep(0,n)
for (i in 1:n){
logmux = splog(mu, as.vector(samples[i,]))
svec[i] = exp(-(lambda/2)*sum(logmux*logmux))
}
numerator = cumsum(svec) # unscaled only
xx = 1:n
yy = (numerator/xx)*uscale*(1/Cpk)
ymin = min(mean(yy)-sd(yy),0.9)
ymax = max(mean(yy)+sd(yy),1.1)
par(mfrow=c(1,2))
plot(xx,yy,"l",main=paste("1. normalizing constant with kappa=",round(lambda,digits=2),sep=""))
abline(h=1,col="red",lwd=2) # horizontal line of normalizing constant
# 2. test my package of 'RiemSphere' --------------------------------------
library(RiemSphere)
yy2.vec = dspnorm(samples, mu, lambda = lambda)
yy2     = cumsum(yy2.vec)/xx*uscale
plot(xx,yy2,"l", main="2. RiemSphere works well?")
abline(h=1,col="red",lwd=2)
library(RiemSphere)
help(dspnorm)
help(rspnorm)
library(Directional)
help(rvmf)
help(rnorm)
library(RiemSphere)
vmf.density()
help(vmf.density)
# compare with vmf.density
y = rnorm(3)
y = y/sqrt(sum(y^2))
mymu = rnorm(3)
mymu = mymu/sqrt(sum(mymu^2))
mykappa = abs(rnorm(1))
kappa = 1.0
vmf.density(y, mykappa, mymu)
dvmf(y, mymu, mykappa)
niter = 12345
val1 = rep(0,niter)
val2 = rep(0,niter)
for (i in 1:niter){
y = rnorm(3)
y = y/sqrt(sum(y^2))
mymu = rnorm(3)
mymu = mymu/sqrt(sum(mymu^2))
mykappa = abs(rnorm(1))
kappa = 1.0
val1[i] = vmf.density(y, mykappa, mymu)
val2[i] = dvmf(y, mymu, mykappa)
}
plot(1:niter,val1-val2)
hist(val1-val2)
niter = 12345
val1 = rep(0,niter)
val2 = rep(0,niter)
mydat = array(0,c(niter,3))
mymu = rnorm(3)
mymu = mymu/sqrt(sum(mymu^2))
mykappa = abs(rnorm(1))
for (i in 1:niter){
y = rnorm(3)
y = y/sqrt(sum(y^2))
mydat[i,] = y
val1[i] = vmf.density(y, mykappa, mymu)
val2[i] = dvmf(y, mymu, mykappa)
}
val3 = dvmf(mydat, mymu, mykappa)
val3
hist(val2-val3)
sqrt(sum((val2-val3)^2))
library(Rfast)
help(rvmf)
library(RiemSphere)
library(RiemSphere)
library(RiemSphere)
help(rvmf)
dvmf(c(0,0,1), c(0,0,1))
dspnorm(c(0,0,1),c(0,0,1))
install.packages("HSAUR2")
library(HSAUR2)
help("HSAURtable")
library(movMF)
help("mix.vmf")
k <- runif(4, 4, 20)
prob <- c(0.2, 0.4, 0.3, 0.1)
mu <- matrix(rnorm(16), ncol = 4)
mu <- mu / sqrt( rowSums(mu^2) )
x <- rmixvmf(200, prob, mu, k)$x
mix.vmf(x, 3)
k <- runif(4, 4, 20)
prob <- c(0.2, 0.4, 0.3, 0.1)
mu <- matrix(rnorm(16), ncol = 4)
mu <- mu / sqrt( rowSums(mu^2) )
x <- rmixvmf(200, prob, mu, k)$x
res3 = mix.vmf(x, 3)$param
res3
res$
names(res)
names(res3)
ls(res3)
k <- runif(4, 4, 20)
prob <- c(0.2, 0.4, 0.3, 0.1)
mu <- matrix(rnorm(16), ncol = 4)
mu <- mu / sqrt( rowSums(mu^2) )
x <- rmixvmf(200, prob, mu, k)$x
res3 = mix.vmf(x, 3)
res3
euclid.inv(c(0,0,1))
library(RiemSphere)
